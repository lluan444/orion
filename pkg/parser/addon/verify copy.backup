/*###############################################################################
  # Licensed Materials - Property of IBM
  # (c) Copyright IBM Corporation 2020. All Rights Reserved.
  #
  # Note to U.S. Government Users Restricted Rights:
  # Use, duplication or disclosure restricted by GSA ADP Schedule
  # Contract with IBM Corp.
  ###############################################################################  */
package addon

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"

	"github.com/Pallinder/go-randomdata"
	"github.com/google/go-containerregistry/pkg/logs"
	"github.com/moby/buildkit/frontend/dockerfile/parser"
	"github.com/spdx/spdx-sbom-generator/pkg/models"
	"github.com/tapestry-discover/pkg/common"
	"github.com/tapestry-discover/pkg/dind"
	"golang.org/x/crypto/sha3"
	"golang.org/x/mod/sumdb/dirhash"
)

const (
	NOASSERTION = "NOASSERTION"
	NOSHA       = "checksum calculation failed. a manual review of install traces is recommended."
)

func displayDockerfile(pDfp string) {
	dat, err := os.ReadFile(pDfp)
	check(err)
	fmt.Print("temp dockerfile = \n" + string(dat))
}
func check(e error) {
	if e != nil {
		panic(e)
	}
}

//VerifyAddOnInstalls :
func VerifyAddOnInstalls(repodir, dockerdata string, buildStage *common.BuildStage) error {
	logs.Debug.Printf("--- verify, repo dir=%s", repodir)
	if len(buildStage.AddOnInstalls) == 0 {
		logs.Debug.Printf("no AddOnInstalls found for build stage = %s", buildStage.StageID)
		return nil
	}

	buildContextDir, err := ioutil.TempDir(os.TempDir(), "build-ctx")
	if err != nil {
		logs.Debug.Printf("error creating build context dir: %s", err.Error())
		return errors.New("unable to create local file")
	}
	//defer os.RemoveAll(buildContextDir)
	pDfp, err := savePartialDockerfile(buildContextDir, dockerdata)
	//defer os.Remove(pDfp)
	if err != nil {
		return err
	}
	logs.Debug.Printf("--- verify, build-ctx=%s", buildContextDir)
	logs.Debug.Printf("--- verify, dockerfile=%s", pDfp)

	imageName := strings.ToLower(randomdata.SillyName())

	if err := dind.BuildImage(repodir, pDfp, imageName); err != nil {
		logs.Debug.Printf("error running dind build: %v", err)
		return errors.New("unable to build Docker image")
	}

	containerID, err := dind.CreateContainer(imageName)
	if err != nil {
		logs.Debug.Printf("error creatting container: %v", err)
		return errors.New("unable to run Dokcer container")
	}

	//unpackDir, _ := ioutil.TempDir(os.TempDir(), "")
	//defer os.RemoveAll(unpackDir)
	unpackDirRootfs := path.Join(buildContextDir, "rootfs")
	os.MkdirAll(unpackDirRootfs, 0744)
	tarfilePath := path.Join(buildContextDir, fmt.Sprintf("%s.tar.gz", imageName))
	logs.Debug.Printf("export image to file system: %s", tarfilePath)
	if err := dind.ExportImageToLocalDir(tarfilePath, containerID); err != nil {
		logs.Debug.Printf("error running dind export: %v", err)
		return errors.New("unable to export Docker image")
	}
	logs.Debug.Printf("untar image file to: %s", unpackDirRootfs)
	if err := dind.UntarImageToLocalDir(tarfilePath, unpackDirRootfs); err != nil {
		logs.Debug.Printf("error running untar: %v", err)
		return errors.New("unable to extract Docker image locally")
	}

	/*osName, _, _ := discoverOSType(unpackDirRootfs)
	osPackages := getInstalledOSPackages(unpackDirRootfs, osName)
	logs.Debug.Printf("os discovered: %v # packages: %d", osName, len(osPackages))
	buildStage.Packages = append(buildStage.Packages, osPackages...)
	*/

	//verify addon installs in image, TODO

	return nil
}

//createImageFs returns the file system from image build for the input dockerfile data
func createImageFs(repodir, dockerfiledata string, buildStage *common.BuildStage) (string, error) {

	//create a temp directory for the file system
	buildContextDir, err := ioutil.TempDir(os.TempDir(), "build-ctx")
	if err != nil {
		logs.Debug.Printf("error creating build context dir: %s", err.Error())
		return errors.New("unable to create local file")
	}
	//defer os.RemoveAll(buildContextDir)

	//save dockerfile data
	pDfp, err := savePartialDockerfile(buildContextDir, dockerfiledata)
	//defer os.Remove(pDfp)
	if err != nil {
		return err
	}
	logs.Debug.Printf("--- verify, build-ctx=%s", buildContextDir)
	logs.Debug.Printf("--- verify, dockerfile=%s", pDfp)

	imageName := strings.ToLower(randomdata.SillyName())

	//build docker image
	if err := dind.BuildImage(repodir, pDfp, imageName); err != nil {
		logs.Debug.Printf("error running dind build: %v", err)
		return errors.New("unable to build Docker image")
	}

	//create a docker container of the image
	containerID, err := dind.CreateContainer(imageName)
	if err != nil {
		logs.Debug.Printf("error creatting container: %v", err)
		return errors.New("unable to run Dokcer container")
	}

	//export the container and untar it to the filesystem
	unpackDirRootfs := path.Join(buildContextDir, "rootfs")
	os.MkdirAll(unpackDirRootfs, 0744)
	tarfilePath := path.Join(buildContextDir, fmt.Sprintf("%s.tar.gz", imageName))
	logs.Debug.Printf("export image to file system: %s", tarfilePath)
	if err := dind.ExportImageToLocalDir(tarfilePath, containerID); err != nil {
		logs.Debug.Printf("error running dind export: %v", err)
		return errors.New("unable to export Docker image")
	}
	logs.Debug.Printf("untar image file to: %s", unpackDirRootfs)
	if err := dind.UntarImageToLocalDir(tarfilePath, unpackDirRootfs); err != nil {
		logs.Debug.Printf("error running untar: %v", err)
		return errors.New("unable to extract Docker image locally")
	}
	return unpackDirRootfs
}

func generateSpdxFromTrace(installs []common.InstallTrace, builddir string) {
	spdxPkgs := []models.Package{}
	for _, install := range installs {
		fmt.Printf("\norigin=%s", install.Origin)
		//origin := install.Origin
		for _, trace := range install.Traces {
			fmt.Printf("\ncmd=%s, so=%s, dest=%s", trace.Command, trace.Source, trace.Destination)
			//des := trace.Destination
			shavalue, loc, err := getSha(trace, builddir)
			fmt.Printf("\nsha=%s, lo=%s", shavalue, loc)
			comment := ""
			if err != nil {
				if len(shavalue) == 0 && len(loc) == 0 { //dir/file not exist
					continue
				} else { //dir/file exists but failed calculate its SHA
					comment = NOSHA
				}
			}
			pkg := models.Package{
				PackageName:             loc,
				SPDXID:                  "",
				PackageVersion:          NOASSERTION,
				PackageSupplier:         NOASSERTION,
				PackageDownloadLocation: install.Origin,
				FilesAnalyzed:           false,
				PackageChecksum:         shavalue,
				PackageHomePage:         "",
				PackageLicenseConcluded: NOASSERTION,
				PackageLicenseDeclared:  NOASSERTION,
				PackageCopyrightText:    NOASSERTION,
				PackageLicenseComments:  NOASSERTION,
				PackageComment:          comment,
				RootPackage:             false,
			}
			spdxPkgs = append(spdxPkgs, pkg)
		}
	}
	b, _ := json.Marshal(spdxPkgs)
	fmt.Printf("\nspdx packages = \n%s", string(b))
}

func getSha(trace common.Trace, dir string) (string, string, error) {
	fmt.Printf("\npath=%s\n", dir+"  "+trace.Destination)
	var hash string
	var err error

	mydes := trace.Destination
	switch trace.Command {
	case "COPY":
		mydes = checkCOPYADDDestination(trace)
	case "ADD":
		mydes = checkCOPYADDDestination(trace)
	case "cp":
		mydes, err = checkCpDestination(trace, dir)
		if err != nil {
			return "", mydes, err
		}
	case "mv":
		mydes, err = checkMvDestination(trace, dir)
		if err != nil {
			return "", mydes, err
		}
	default: //do nothing
	}
	fmt.Printf("new des = %s\n", mydes)

	info, err := os.Stat(dir + mydes)
	if os.IsNotExist(err) {
		fmt.Printf("\nfolder/file %s does not exist", dir+trace.Destination)
		return "", "", err
	}
	if info.IsDir() {
		hash, err = dirhash.HashDir(dir+mydes, "", dirhash.DefaultHash)
		if err != nil {
			fmt.Printf("\nsha for folder %s not available", dir+trace.Destination)
			return hash, mydes, err
		}
	} else {
		data, err := ioutil.ReadFile(dir + mydes)
		if err != nil {
			return hash, mydes, err
		} else {
			hash = fmt.Sprintf("SHA256:%x", sha3.Sum256(data))
		}
	}
	return hash, mydes, nil
}

func checkCOPYADDDestination(trace common.Trace) string {
	des := trace.Destination
	if strings.HasSuffix(des, "/") { //des is a directory
		if !strings.HasSuffix(trace.Source, "/") { //source is a file
			sostrs := strings.Split(trace.Source, "/")
			so := sostrs[len(sostrs)-1] //get source filename
			des += so
		}
	}
	return des
}

func checkCpDestination(trace common.Trace, dir string) (string, error) {
	des := trace.Destination
	des = strings.TrimSuffix(des, ".") //e.g. /usr/bin/. --> /usr/bin/
	des = strings.TrimSuffix(des, "/") //e.g. /usr/bin/ --> /usr/bin
	info, err := os.Stat(dir + des)    // e.g. /tmp/build-ctx00032/rootfs/usr/bin
	if os.IsNotExist(err) {
		fmt.Printf("\nfolder/file %s does not exist", dir+des)
		return "", err
	}
	if info.IsDir() { // destination is a directory
		sostrs := strings.Split(trace.Source, "/")
		so := sostrs[len(sostrs)-1]
		fmt.Printf("so = %s, sostrs=%v\n", so, sostrs)
		des += "/" + so
	}
	return des, nil
}

func checkMvDestination(trace common.Trace, dir string) (string, error) {
	des := trace.Destination
	sostrs := strings.Split(trace.Source, "/")
	so := sostrs[len(sostrs)-1]
	fmt.Printf("so = %s, sostrs=%v\n", so, sostrs)
	if strings.HasSuffix(des, "/.") { //e.g. /usr/bin/.
		des += "/" + so
	}
	return des, nil
}

func GeneratePartialDockerData(buildArgs map[string]string, cmds []*parser.Node) string {
	data := ""
	for k, v := range buildArgs {
		data += "ARG " + k + "=" + v + "\n"
	}
	for _, cmd := range cmds {
		data += cmd.Original + "\n"
	}
	return data
}

func savePartialDockerfile(dir, data string) (string, error) {
	tmpFp, err := ioutil.TempFile(dir, "Dockerfile")
	if err != nil {
		return "", errors.New("error creating a temp file: " + err.Error())
	}
	defer tmpFp.Close()

	tmpFp.WriteString(data)
	tmpFp.WriteString("\n")
	logs.Debug.Printf("savePartialDockerfile name=%s", tmpFp.Name())
	return tmpFp.Name(), nil
}
